---
title: 物联App开发概述
layout: post
tag: 物联网相关
summary: 
featured-img: emile-perron-190221
---
## 一、 通信协议概述
### 1.1 通信协议的整体框架
![image.png](http://upload-images.jianshu.io/upload_images/3980862-573c66c1e82d11eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**通信协议条目**
* T口、U口使用TCP长连接；L口使用UDP协议。
* 该协议中的数据，如无特殊说明，均使用网络字节序。
* 该协议中的命令返回参数Result，统一使用0x00表示操作成功，其他值表示错误。错误码的含义待定。

**协议格式**
![image.png](http://upload-images.jianshu.io/upload_images/3980862-9e5c46d492fe6a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**命令字的说明**
内层协议数据的第1个字节为协议命令。协议命令长度为单字节，低5位用于表示命令号，高3位用于表示此条协议的类型
![image.png](http://upload-images.jianshu.io/upload_images/3980862-61738988bff6a1b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
其中，T口专用协议、U口专用协议，由Server立刻返回。而设备专用控制协议、公共协议，如果发往Server的话，则由Server进行透传转发，Server并不会立刻返回数据（0x61心跳命令除外

**安全性说明**
2.2. 加密机制说明
该物联网系统使用SSL协议对TCP通信（T口，U口协议）进行加密。设备和APP需要向受信库中添加根证书，用来**验证服务器身份**。
局域网内通过UDP通信（L口协议），**不加密**。

**具体目录一览**
![image.png](http://upload-images.jianshu.io/upload_images/3980862-313d4c416f92b09c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](http://upload-images.jianshu.io/upload_images/3980862-e7ec29c7f8d31b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](http://upload-images.jianshu.io/upload_images/3980862-da9fe9356aa8680e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2 具体进入协议内部
#### 1.2.1 常见的协议
>**带有Broadcast说明会局域网广播出来,括号里面的T,L,U表明了试用的协议**
>![image.png](http://upload-images.jianshu.io/upload_images/3980862-49e9db4627eefb91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](http://upload-images.jianshu.io/upload_images/3980862-044e845305a80419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>**关于订阅命令**
>![image.png](http://upload-images.jianshu.io/upload_images/3980862-9304a26e3200c595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>![image.png](http://upload-images.jianshu.io/upload_images/3980862-6288d60a14bf0b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
以上图为例子: 如果需要订阅设备上下线的话，那么0x83命令后面的Cmd参数就必须0x85,而因为0x85的订阅不需要参数，说以Param上直接填写0x00即可。此外0x85注意看第一栏为Server Request:(PS:此处个人此处通信协议描述并不贴切，应该为Push或者直接沿用Response)表示的是服务器推送过来的形式将会如图。

### 1.3 负载均衡服务器
>![image.png](http://upload-images.jianshu.io/upload_images/3980862-a7ac139b2414a740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>上图是个最简单的负载均衡实例， 应用服务器并不直接与用户相连， 用户连接负载均衡服务器，然后由负载均衡服务器把消息转发给实际应用服务器。负载均衡器内部会根据应用服务器的负载情况，决定把消息转发给哪台服务器处理。同时负载均衡器还可以对用户屏蔽应用服务器失效，只要把用户的消息转发到非失效服务器即可。

## 补充说明
### 关于时间问题
考虑到设备可能销往国外，系统的时间和时区问题，用如下方式处理：
a）设备从标准时间服务器pool.ntp.org获取并保存世界标准时间UTC（GMT+0），与时区无关。
b）用户设置的定时信息，保存在设备中。
c）整个系统通信中发送和接收的时间数据，均使用世界标准时间UTC， 与时区无关。
d）APP是与时区相关的。APP接收到的时间数据，是UTC时间，但呈 现到用户界面的时候，需要根据APP或手机设定的时区进行转换。同样 的，APP发送出去的时间数据，是UTC时间，需要根据APP或手机设 定的时区进行转换。

## 二、WIFI通信的具体流程
### 2.1 WIFI通信的具体流程概述
![WiFi_APP_Network_Init.png](http://upload-images.jianshu.io/upload_images/3980862-9298ede0065c3884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2 iOSWIFI库具体流程图
#### 2.2.1 UDP的心跳流程图
![UDP心跳流程图.png](http://upload-images.jianshu.io/upload_images/3980862-d25a4fc604de5e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2.2.2 TCP连接过程流程图
![TCP部分网络流程简图.png](http://upload-images.jianshu.io/upload_images/3980862-b19a8a5c921f13b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 三、WIFI框架的具体内核介绍
### 3.1 观察者模式
![image.png](http://upload-images.jianshu.io/upload_images/3980862-8f3e86f3d9d0d27f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](http://upload-images.jianshu.io/upload_images/3980862-d44ac9cb70bdf6da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](http://upload-images.jianshu.io/upload_images/3980862-f773920e310654dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](http://upload-images.jianshu.io/upload_images/3980862-95264b279e9fa85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 3.2 iOS系统内部的观察者模式
KVO和通知中心
具体实现的原理这里赘述，有兴趣可以参考对一个的博客。

### 3.3 各个板块的职责
#### 3.3.1 整体框架的目录结构
**网络监听部分考虑到其他项目也可以用到因此这里独立出去**
![image.png](http://upload-images.jianshu.io/upload_images/3980862-d7326af6514b4909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**核心部分的代码**
![image.png](http://upload-images.jianshu.io/upload_images/3980862-99379ed7f1342bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**整体框架的系统流程图**
![SLWIFI库的整体构架.png](http://upload-images.jianshu.io/upload_images/3980862-023b8cfefc870cf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 3.4 可以改进的地方？？
#### 3.4.1 使用NSHashTable代替NSMutableArray的存储结构
#### 3.4.2 根据需要可以引擎中自己增加监听进入前台和后台的方法，更加智能
常见的系统通知,可选项
```
UIKIT_EXTERN NSNotificationName const UIApplicationDidEnterBackgroundNotification       NS_AVAILABLE_IOS(4_0);
UIKIT_EXTERN NSNotificationName const UIApplicationWillEnterForegroundNotification      NS_AVAILABLE_IOS(4_0);
UIKIT_EXTERN NSNotificationName const UIApplicationDidFinishLaunchingNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationDidBecomeActiveNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationWillResignActiveNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationDidReceiveMemoryWarningNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationWillTerminateNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationSignificantTimeChangeNotification;
UIKIT_EXTERN NSNotificationName const UIApplicationWillChangeStatusBarOrientationNotification __TVOS_PROHIBITED; // userInfo contains NSNumber with new orientation
UIKIT_EXTERN NSNotificationName const UIApplicationDidChangeStatusBarOrientationNotification __TVOS_PROHIBITED;  // userInfo contains NSNumber with old orientation
UIKIT_EXTERN NSString *const UIApplicationStatusBarOrientationUserInfoKey __TVOS_PROHIBITED;            // userInfo dictionary key for status bar orientation
UIKIT_EXTERN NSNotificationName const UIApplicationWillChangeStatusBarFrameNotification __TVOS_PROHIBITED;       // userInfo contains NSValue with new frame
UIKIT_EXTERN NSNotificationName const UIApplicationDidChangeStatusBarFrameNotification __TVOS_PROHIBITED;        // userInfo contains NSValue with old frame
UIKIT_EXTERN NSString *const UIApplicationStatusBarFrameUserInfoKey __TVOS_PROHIBITED;                  // userInfo dictionary key for status bar frame
UIKIT_EXTERN NSNotificationName const UIApplicationBackgroundRefreshStatusDidChangeNotification NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;
```

#### 3.4.3 Think of 如何将该框架封装成透传的框架？？
#### 3.4.4 GCD的定时都在主线程上跑，是否需要考虑迁移??

## 四、该WIFI库的使用
### SLHadlinksWIFIDemo
##### 一、文件夹说明
* NetWorkMonitor 用于监听网络环境，由于监听网络部分不仅仅在WIFI里面使用到所以将部分单独成一个模块。<此处引用了 pod 'Reachability', '~>3.2’ > 请注意包含socketEngine  为该框架的核心部分 
+ Packet 主要包含了WIFI项目发送命令的封包函数
- HalinksPacketTool 包含着最基本的封包函数，此处因根据各个通信协议之间的细微差异来修改对应的数据长度、厂家代码等信息。
- HadlinksPacketFactory 用于封包，其中已经封装了标准的通用协议部分的封包
* ResponseAnalysis 纯粹的解包 将包解析成WIFI的FrameWork包和有效数据字典，两部分。具体的参考源码
* SLGCDTimerTool为了方便使用GCD定时器引入的类，在socketServiceEngine等地方有使用
* Socket 实现了LocalService和RemoteService对应于Udpsocket与Tcpsocket的封装
* socketServiceEngine 是核心部分负责管理自动连接服务器和设备统一管理。WIFI网络切换，APP进入后台和回来前台的统一处理。
* WIFIDevice的基设备，用户自定义的WIFI设备，必须继承该设备。已经自身独立UDP心跳。
* Subscribe里面包含着“SubScribeBoardCastProtocol”用于处理所有订阅命令和所有订阅需要实现的协议，具体的使用方法可以参考BLAirSocketPushBehaviour中的使用。

##### 修改说明
2016.11.02增加了注销登录的接口 
```
/**
 *  注销登录的接口
 *
 *  注销登录将中断和TCP服务器的通信，断开和所有设备的心跳包，并且取消相应的订阅<不保证一定成功>
 *  LocalService解绑
 *  将引擎中对应的用户名和密码清空  并且将引擎标示为未登录状态
 */
-(void) logOut{
    _userName = @"";
    _password = @"";
    _alrReadLoadIn = @(NO);
    [self removeAllDevice];        //包含取消订阅
    [localservice closeUdpBind];
    //断开和服务器的连接
    [self disconnect];
}
```

##### 使用指南
注意DEMO中使用所有的LOG均为DDLOG包装，在socketConfig.h中可以看到
所以请在appDelegate中初始化DDLOG事宜，如果不想理会该部分报错，请将以上socketConfig.h里面的宏定义宏定义改成NSLOG就能规避错误,并且添加CocoaLumberjack第三方框架<如下方的代码  socketConfig.h>
```
//MARK - Log的统一处理
#define     UDPPrint    0
#define     TCPPrint    1

#if  UDPPrint
#define    UDPLogError(...)     DDLogError(__VA_ARGS__)
#define    UDPLogInfo(...)      DDLogInfo(__VA_ARGS__)
#define    UDPLogWarn(...)      DDLogWarn(__VA_ARGS__)
#define    UDPLogVerbose(...)   DDLogVerbose(__VA_ARGS__)
#define    UDPLogDebug(...)     DDLogDebug(__VA_ARGS__)
#else
#define    UDPLogError(...)     {}
#define    UDPLogInfo(...)      {}
#define    UDPLogWarn(...)      {}
#define    UDPLogVerbose(...)   {}
#define    UDPLogDebug(...)     {}
#endif

#if  TCPPrint
#define    TCPLogError(...)     DDLogError(__VA_ARGS__)
#define    TCPLogInfo(...)      DDLogInfo(__VA_ARGS__)
#define    TCPLogWarn(...)      DDLogWarn(__VA_ARGS__)
#define    TCPLogVerbose(...)   DDLogVerbose(__VA_ARGS__)
#define    TCPLogDebug(...)     DDLogDebug(__VA_ARGS__)
#else
#define    TCPLogError(...)     {}
#define    TCPLogInfo(...)      {}
#define    TCPLogWarn(...)      {}
#define    TCPLogVerbose(...)   {}
#define    TCPLogDebug(...)     {}
#endif
```

######1.监听网络环境
1.请在AppDelegate.m中增加监听网络代码，考虑到监听网络不仅仅引擎会使用到所以将其暴露出来淡出成一个类
```
#import "NetworkMonitorTool.h" 
//添加socket部分的引擎部分
#import "socketServiceEngine.h"

@interface AppDelegate ()<NetworkMonitorToolDelegate>

@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
   [NetworkMonitorTool sharedNetworkMonitorTool].NetWorkMonitorDelegate = self;
   return YES; 
}
```
2.并在网络状况发生改变的情况下告知socket引擎<务必告诉引擎，网络情况的变化>
```
-(void) networkStatusChanged:(NetworkStatus) status{
//告诉引擎当前网络的变化
    [socketServiceEngineInstance networkStatusChanged:status];
}
```

###### 2.APP进入前台和进入后台都需要告知socket引擎代码如下：
```
- (void)applicationDidEnterBackground:(UIApplication *)application { 
    DDLogWarn(@"%s %@",__func__, application);
    [[socketServiceEngine sharedInstance] applicationDidEnterBackground:application];
} 

- (void)applicationDidBecomeActive:(UIApplication *)application { 
    DDLogWarn(@"%s %@",__func__, application);
    [[socketServiceEngine sharedInstance] applicationDidBecomeActive:application]; 
}
```

######3.定义属于自己的WiFi协议包
修改该方法来定制属于你们自己的协议，以上方法采用搏来的协议编写，主要涉及数据长度，厂家代码，设备类型，授权码，不同给的项目可能存在差异。
```
+(NSData*) packetWithDetailData:(NSData *) rowdata Index:(uint16_t) index Device:(WIFIDevice *) device  Flag:(uint8_t) flag{
    uint8_t rowLen = rowdata.length;
    uint8_t totalLen = rowLen + 16;
    uint8_t *pack = (uint8_t *)malloc(totalLen);
    
    //PV & Flag
    pack[0] = 0xA1;
    pack[1] = flag;
    
    //MAC Address
    if (device.macAddress.length != 12 || device.macAddress == nil || [device.macAddress isEqualToString:@""]) {  //不合理的MAC地址或者MAC地址为空
        for (int i = 2; i < 8; i++) {
            pack[i] = 0xff;
        }
    }else{
        NSData* macdata = [HalinksPacketTool getMacDataFromString:device.macAddress];
        Byte *bytes = (Byte *)[macdata bytes];
        for (int i = 2; i < 8; i++) {
            pack[i] = bytes[i-2];
        }
    }
    
    //长度
    pack[8] = totalLen - 9;
    pack[9] = 0x00;
    
    //协议序号
    pack[10] = ((index >> 8)&0xff);  //高字节
    pack[11] = (index&0xff);         //低字节
    
    //厂家代码
    if (device.companyCode) {
        uint8_t companyCode = (uint8_t)[self hexValuesWith:device.companyCode];
        pack[12] = companyCode;
    }else{
        pack[12] = 0x00;
    }
    
    //授权码
    if (device.authCode) {
        uint16_t authCode = (uint16_t)[self hexValuesWith:device.authCode];
        pack[13] = ((authCode >> 8)&0xff);  //高字节
        pack[14] = (authCode&0xff);         //低字节
    }else{
        pack[13] = 0x00;                    //高字节
        pack[14] = 0x00;                    //低字节
    }
    
    //设备类型
    if (device.deviceType) {
        uint8_t devicetype = (uint8_t)[self hexValuesWith:device.deviceType];
        pack[15] = devicetype;
    }else{
        pack[15] = 0x00;
    }
    
    //具体数据部分
    Byte *bytes = (Byte *)[rowdata bytes];
    for (int i = 0; i < rowLen; i++) {
        pack[16+i] = bytes[i];
    }
    
    //封包
    NSData* packet = [NSData dataWithBytes:pack length:totalLen];
    free(pack);
    return packet;
}
```

######4.配置自己的socketEngine,通过SLWIFIEngine/SocketEngine(引擎)/socket/SocketConfig.h
比如：域名，协议端口，TCP和UDP的是否输出，命令号，接入码等等，具体修改请根据注释说明
```
//MARK - 根据Halinks的通信协议更改
#define     UdpBindPort             19530
#define     AppBalanceHost          @"bolai-test.yunext.com"   //minshi-test.yunext.com
#define     AppBalancePort          19591                      //19591   13593

//是否屏蔽自己发送出去UDP广播包 1 打开  0 关闭
#define     FilterSelfBrocast       1

//       Device部分
#define DeviceType          0xD1    //设备类型
#define DeviceFactoryCode   0xF1    //厂家代码
//接入码:62 72 79 74 79 55

//       APP部分
#define     AppDeviceType       0xBB    //aa表示安卓 bb表示IOS
#define     APPFactoryCode      0xA1    //厂家代码
//接入码:62 72 79 74 79 4e

//===========Socket引擎对应的设备类型定义用于查找设备使用=================
#define    BrytyDeviceType      @"D1"           //设备类型表示空气净化器
#define    BrytyFactoryCode     @"F1"           //表示使用利尔达的WIFI模块
#define    BrytyAirDefaultName  @"搏来空气净化器"  //配置成功之后，设备的默认名称
#define    OtherDefaultName     @"其他设备"       //配置成功之后，设备的默认名称

//====================线程名=============================
#define SocketEngineQueueName  @"SocketEngineQueueName"

//==============根据数据帧的格式定义======================
#define HeadNoHiddenTag     1          //协议中第一部分
#define HiddenTag           2          //协议中第二部分
#define HeadNoHiddenLen     9          //第一部分协议的长度

//发送部分的超时时间
#define UDPTimeout          4
#define TCPTimeout          5

//MARK - Log的统一处理
#define     UDPPrint    0
#define     TCPPrint    1

/**********************命令部分的统一宏定义*******************/
//L口专用协议
#define     DiscoverDevice_CMD        (0x23)        //(UDP Broadcast)
#define     SwichLock_CMD             (0x24)

//U口专用协议
#define     GetWorkServer_CMD         (0x81)
#define     JoinWorkServer_CMD        (0x82)
#define     SwichSubscribe_CMD        (0x83)
#define     QuertTcpOnline_CMD        (0x84)
#define     ServicePushOnline_CMD     (0x85)
#define     GetSoftwareInfo_CMD       (0x86)

//T、L、U口公共协议
#define     HearBeat_CMD                (0x61)
#define     GetHardwareInfo_CMD         (0x62)
#define     SetHardWareAlias_CMD        (0x63)
#define     UpdateHardware_CMD          (0x65)

//MARK - 可以根据需要增加专用控制协议
#define     OnOrOFF_CMD                 (0x01)
#define     Level_CMD                   (0x02)
#define     Sleep_CMD                   (0x03)
#define     ChildrenLock_CMD            (0x04)
#define     GetDeviceStatus_CMD         (0x05)
#define     DeviceStatusReport_CMD      (0x0f)
#define     Brightness_CMD              (0x15)
#define     UvLight_CMD                 (0x16)

/**********************为了方便位操作而引入******************/
```

######5.定制属于你个人或者某个设备的订阅列表，以及订阅行为
该部分必须实现，而且订阅列表中至少包含设备远程上下线的命令，否则引擎将无法为你订阅上下线的推送，以下以搏来为例，该订阅行为实例必须实现该协议
1.必须实现“SubScribeBoardCastProtocol”该协议
```
#import <Foundation/Foundation.h>
#import "WIFIDevice.h"
#import "SubScribeBoardCastProtocol.h"

@interface BLAirSocketPushBehaviour : NSObject<SubScribeBoardCastProtocol>

@end
```
2.懒加载订阅列表，针对订阅中TCP服务器推送和数据和设备BoardCast广播的数据进行，自定义的处理，方便订阅的灵活拓展。
```
//处理订阅信息的内容<根据具体不同的项目传递不同的设备>
-(void) getSubScribePushMsgDictionary:(NSDictionary *) dict WithDevice:(id) device{
    NSDictionary* validDict = dict[ValidResponseKey];
    NSDictionary* frameDict = dict[FrameAnalysisKey];
    NSNumber* cmdNum = frameDict[FrameCmdKey];
    switch ([cmdNum integerValue]) {
        case ServicePushOnline_CMD:   //上下线部分引擎已经处理不需要处理
        {
            break;
        }
        case DeviceStatusReport_CMD:
        {
            BLAirCleaner* blDevice = (BLAirCleaner*) device;
            blDevice.devicestatus = [validDict[@"Status"] unsignedCharValue];
            blDevice.level = [validDict[@"Level"] unsignedCharValue];
            blDevice.sleepmode = [validDict[@"Sleep_Mode"] unsignedCharValue];
            blDevice.children_lock = [validDict[@"Children_Lock"] unsignedCharValue];
            //只是uv灯的亮度信息
            blDevice.uvlight = [validDict[@"Light"] unsignedCharValue];
            blDevice.pmvalue = [validDict[@"PM"] unsignedIntegerValue];
            blDevice.temp = [validDict[@"Temp"] unsignedCharValue];
            blDevice.hum = [validDict[@"Hum"] unsignedCharValue];
            blDevice.voc = [validDict[@"VOC"] unsignedCharValue];
            blDevice.brightness = [validDict[@"Brightness"] unsignedCharValue];
            blDevice.BLindex = [validDict[@"Bryty_Index"] unsignedCharValue];
            
            /****该方法为wifiDevice的方法 设备状态改变需要通知下设备，让设备将消息传递给代理****/
            [blDevice getStatusChangeResponse:dict TcpOrUdp:ReceivePacketTCP];
            break;
        }
        default:
            break;
    }
}

//处理局域网广播的信息<根据具体不同的项目传递不同的设备>
-(void) getBoardCastMsgDictionary:(NSDictionary *) dict WithDevice:(id) device{
    NSDictionary* validDict = dict[ValidResponseKey];
    NSDictionary* frameDict = dict[FrameAnalysisKey];
    NSNumber* cmdNum = frameDict[FrameCmdKey];
    switch ([cmdNum integerValue]) {
        case DeviceStatusReport_CMD:
        {
            BLAirCleaner* blDevice = (BLAirCleaner*) device;
            blDevice.devicestatus = [validDict[@"Status"] unsignedCharValue];
            blDevice.level = [validDict[@"Level"] unsignedCharValue];
            blDevice.sleepmode = [validDict[@"Sleep_Mode"] unsignedCharValue];
            blDevice.children_lock = [validDict[@"Children_Lock"] unsignedCharValue];
            //只是uv灯的亮度信息
            blDevice.uvlight = [validDict[@"Light"] unsignedCharValue];
            blDevice.pmvalue = [validDict[@"PM"] unsignedIntegerValue];
            blDevice.temp = [validDict[@"Temp"] unsignedCharValue];
            blDevice.hum = [validDict[@"Hum"] unsignedCharValue];
            blDevice.voc = [validDict[@"VOC"] unsignedCharValue];
            blDevice.brightness = [validDict[@"Brightness"] unsignedCharValue];
            blDevice.BLindex = [validDict[@"Bryty_Index"] unsignedCharValue];
            
                /****该方法为wifiDevice的方法 设备状态改变需要通知下设备，让设备将消息传递给代理****/
            [blDevice getStatusChangeResponse:dict TcpOrUdp:ReceivePacketUDP];
            break;
        }
        default:
            break;
    }
}

@end

```

###### 6. App登陆成功，通知引擎。socketEngine将自动完成连接工作服务器，绑定UDP端口等事宜，如DEMO代码
```
- (IBAction)loginClick:(BLLoadBtn *)sender {
    [SLTipHudTool showSuccessWithWindowMessage:@"登录请求中..."];
    LoadParms* loadParms = [[LoadParms alloc] init];
    loadParms.username = self.userTextField.text;
    loadParms.password = [SLHttpsTool md5:self.passwordTextField.text];
    loadParms.token = @"";
    
    [RegisterLoadTool loadWithLoadParms:loadParms success:^(id json) {
        [SLTipHudTool hideInView:[SLUITool getwindow]];
        [SLTipHudTool showSuccessWithWindowMessage:@"登陆成功"];
        //标记下登陆的状态
        APPStatusToolInstance.loaded = [NSNumber numberWithBool:YES];
        /*****告知引擎登陆成功了，可以根据用户名了密码连接工作服务器和设备了*****/
        [[socketServiceEngine sharedInstance] loadSuccessWithUserName:loadParms.username Password:loadParms.password];
        [BLUIEngineTool showMainPage];
        DDLogDebug(@"登陆成功");
    } fail:^(NSError *error) {
        [SLTipHudTool hideInView:[SLUITool getwindow]];
        DDLogWarn(@"登陆失败%@", error);
        DDLogDebug(@"登陆失败");
    }];
}
```

######7. 从服务中刷新出最新的列表，通知socketEngine更新列表，并且传递属于每个设备自己的订阅列表，代码如下
```
#pragma mark - 下拉刷新
-(void) loadMoreData{
    GetDeviceListParam *param = [[GetDeviceListParam alloc] init];
    SLWeeK(weakself);
    [HomeHttpsTool getDeviceListWith:param success:^(id json) {
        if ([SLHttpsTool checkHttpsSuccess:json]) {
            [weakself.tableView.mj_header endRefreshing];
//            DDLogDebug(@"设备列表%@", json);
            NSArray* deviecelist = json[@"list"];
            NSArray* devicemodelist = [BLAirCleaner mj_objectArrayWithKeyValuesArray:deviecelist];
            //在这里初始化订阅部分
            for (BLAirCleaner* airClear in devicemodelist) {
                BLAirSocketPushBehaviour *pushBehaviour = [[BLAirSocketPushBehaviour alloc] init];
                /****这里可以自定义自己的订阅列表，未定义为懒加载的订阅列表，包含设备远程在离线，设备状态改变****/
//                NSArray* tempArray = @[@(ServicePushOnline_CMD), @(DeviceStatusReport_CMD)];
//                pushBehaviour.subScribelist = [[NSMutableArray alloc] initWithArray:tempArray];
                //使用懒加载的订阅数组
                airClear.pushBehaviour = pushBehaviour;
            }
            /***告知socketEngine更新设备，包括设备名称，设备的增加和删除***/
            [socketServiceEngineInstance updateDevicelistWith:devicemodelist];
            [weakself.tableView reloadData];
          }else{
             [weakself.tableView.mj_header endRefreshing];
        }
    } fail:^(NSError *error) {
        [weakself.tableView.mj_header endRefreshing];
    }];
}
```

######8.主界面和设备详细界面实现状态的同步,所有设备信息的同步均使用代理方法
1.主页面（所有设备）状态的同步，采用引擎的代理实现代码如下
【**PS：最新的版本对此不作要求，只需要viewDidLoad中成为代理，然后再 delloc中移除即可**】
```
-(void) viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    [self.tableView reloadData];
    [socketServiceEngineInstance addEngineDelegate:self];
}

-(void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    [socketServiceEngineInstance removeEngineDelegate:self];
}

#pragma mark - 设备引擎的代理 socketServiceEngineDelegate
-(void) socketServiceEngine:(socketServiceEngine *) engine DeviceStatusChange:(WIFIDevice *) device Event:(WIFIDeviceChangeEvent) event{
    [self.tableView reloadData];
}
```

2.单个设备的状态的同步，直接成为需要监听设备的代理即可，DEMO代码如下
```
-(void) viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    [self refreashUI];
    if (self.clear != nil) {
        [self.clear addWIFIDelegate:self];  //设备模型的代理
    }
}

-(void) viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    [self.clear removeWIFIDelegate:self];
}

#pragma mark - WIFIDeviceDelegate
-(void) WIFIDeviceStatusChange:(WIFIDevice *) device{
    [self refreashUI];
}
```

######9. 关于发送的方法以及心跳管理都封装在WIFIDevice类中这里补充一点
```
/****************************发送命令******************************/
-(void) postPacket:(NSData *) packet complete:(SendCmdCallBackBlock) block;
-(void) postPacket:(NSData *) packet timeOut:(NSTimeInterval) timeout complete:(SendCmdCallBackBlock) block;
```
两方法的区别在于，方法一采用的是socketconfig的定义的超时时间，方法2可以让开发者自定义超时时间，用来应对，某些特殊使用

######10.另外该库来提供实现代理方法实时跟进当前WIFI ssid的等应用，详细见DEMO中配置部分。

## 参考文档和书籍
博来空气净化器通信协议
[宁波海大WIFI项目开发注意事项](https://redmine.yunext.com/redmine/projects/bugu-software/wiki/WiFi项目注意事项)
[IOS设计模式-观察者模式](http://www.cnblogs.com/goodboy-heyang/p/5265675.html)